# mingru (WIP)

[![Build Status](https://github.com/mgenware/mingru/workflows/Build/badge.svg)](https://github.com/mgenware/mingru/actions)
[![MEAN Module](https://img.shields.io/badge/MEAN%20Module-TypeScript-blue.svg?style=flat-square)](https://github.com/mgenware/MEAN-Module)
[![npm version](https://img.shields.io/npm/v/mingru.svg?style=flat-square)](https://npmjs.com/package/mingru)
[![Node.js Version](http://img.shields.io/node/v/mingru.svg?style=flat-square)](https://nodejs.org/en/)

Convert [mingru-models](https://github.com/mgenware/mingru-models) to Go code.

**All APIs are subject to change before 1.0.0**

Goals:

- **No performance penalty at runtime**, mingru is an SQL builder, not an ORM
- **Strongly typed models**, models are defined in TypeScript not Go
- Currently focuses on Go and MySQL/MariaDB

---

# NOTE: The documentation below is outdated!!! We are working on a brand new documentation site. Stay tuned.

---

## A quick example

### Step 1: Define models

Models are defined in [mingru-models](https://github.com/mgenware/mingru-models). Let's create a simple user model `user.ts`:

```ts
// ----------- User table model (user.ts) -----------
import * as mm from 'mingru-models';

class User extends mm.Table {
  id = mm.pk();
  name = mm.varChar(100);
  sig = mm.text().nullable;
  age = mm.int();
}

export default mm.table(User);
```

### Step 2: Define actions

Create another file (`userTA.ts`) for table actions and import the user table (`user.ts`) we just defined above:

```ts
// ----------- User table actions (userTA.ts) -----------
import * as mm from 'mingru-models';
import user from './user';

export class UserTA extends mm.TableActions {
  // Select a user by ID.
  selectUser = mm.selectRow(user.id, user.name, user.sig).byID();
  // Select all users and order by their names.
  selectAllUsers = mm.selectRows(user.id, user.name, user.sig).orderByAsc(user.name);
  // Select a single user signature field by ID.
  selectUserSig = mm.selectField(user.sig).byID();

  // Update a user by ID.
  updateUser = mm.updateOne().setInputs(user.name, user.sig).byID();

  // Update all user signatures to an empty string.
  updateAllSigToEmpty = mm.unsafeUpdateAll().set(user.sig, mm.sql`''`);

  // Delete a user by ID.
  deleteByID = mm.deleteOne().byID();

  // Delete all users by a specified name.
  deleteByName = mm.deleteSome().whereSQL(user.name.isEqualToInput());

  // Delete all users.
  deleteAll = mm.unsafeDeleteAll();

  // Insert a new user.
  insertUser = mm
    .insertOne()
    .set(user.sig, mm.sql`'Default signature!'`)
    .setInputs(user.name, user.age);
}

export default mm.tableActions(user, UserTA);
```

### Step 3: Generate Go Code

Install `mingru-tsconfig`:

```sh
yarn add mingru-tsconfig -D
```

Set `extends` to `mingru-tsconfig` in your local `tsconfig.json`:

```json
{
  "extends": "mingru-tsconfig"
}
```

Create a `mingru.ts` file, which will start the build process to generate Go and SQL code.

```ts
import * as mr from 'mingru';
// Import table actions.
import userTA from './userTA';
// Import tables if you need to generate CREATE TABLE SQL files.
import user from './user';

(async () => {
  const dialect = new mr.MySQL();
  // Build Go code to '../da/` directory.
  const builder = new mr.Builder(dialect, './data_access_layer/', {
    // Clean build directory on each build.
    cleanBuild: true,
  });

  const actions = [userTA];
  const tables = [user];
  // Start the build process by calling the `build` method.
  await builder.buildAsync(async () => {
    // Generate Go source files.
    await builder.buildActionsAsync(actions);
    // Generate CREATE TABLE SQL files.
    await builder.buildCreateTableSQLFilesAsync(tables);
  });
})();
```

It's also recommended to use `ts-node` and add a build command to `package.json` scripts section:

```json
{
  "scripts": {
    "build": "ts-node mingru.ts"
  }
}
```

Now you can build your project using `yarn build`.

Below is the code generated by mingru:

<details><summary>`user_ta.go` (click to expand/collapse)</summary>
<p>

```go
/******************************************************************************************
 * This file was automatically generated by mingru (https://github.com/mgenware/mingru)
 * Do not edit this file manually, your changes will be overwritten.
 ******************************************************************************************/

package da

import "github.com/mgenware/mingru-go-lib"

// TableTypeUser ...
type TableTypeUser struct {
}

// User ...
var User = &TableTypeUser{}

// ------------ Actions ------------

// DeleteAll ...
func (mrTable *TableTypeUser) DeleteAll(queryable mingru.Queryable) (int, error) {
	result, err := queryable.Exec("DELETE FROM `user`")
	return mingru.GetRowsAffectedIntWithError(result, err)
}

// DeleteByID ...
func (mrTable *TableTypeUser) DeleteByID(queryable mingru.Queryable, id uint64) error {
	result, err := queryable.Exec("DELETE FROM `user` WHERE `id` = ?", id)
	return mingru.CheckOneRowAffectedWithError(result, err)
}

// DeleteByName ...
func (mrTable *TableTypeUser) DeleteByName(queryable mingru.Queryable, name string) (int, error) {
	result, err := queryable.Exec("DELETE FROM `user` WHERE `name` = ?", name)
	return mingru.GetRowsAffectedIntWithError(result, err)
}

// InsertUser ...
func (mrTable *TableTypeUser) InsertUser(queryable mingru.Queryable, name string, age int) (uint64, error) {
	result, err := queryable.Exec("INSERT INTO `user` (`sig`, `name`, `age`) VALUES ('Default signature!', ?, ?)", name, age)
	return mingru.GetLastInsertIDUint64WithError(result, err)
}

// UserTableSelectAllUsersResult ...
type UserTableSelectAllUsersResult struct {
	ID   uint64
	Name string
	Sig  *string
}

// SelectAllUsers ...
func (mrTable *TableTypeUser) SelectAllUsers(queryable mingru.Queryable) ([]*UserTableSelectAllUsersResult, error) {
	rows, err := queryable.Query("SELECT `id`, `name`, `sig` FROM `user` ORDER BY `name`")
	if err != nil {
		return nil, err
	}
	result := make([]*UserTableSelectAllUsersResult, 0)
	defer rows.Close()
	for rows.Next() {
		item := &UserTableSelectAllUsersResult{}
		err = rows.Scan(&item.ID, &item.Name, &item.Sig)
		if err != nil {
			return nil, err
		}
		result = append(result, item)
	}
	err = rows.Err()
	if err != nil {
		return nil, err
	}
	return result, nil
}

// UserTableSelectUserResult ...
type UserTableSelectUserResult struct {
	ID   uint64
	Name string
	Sig  *string
}

// SelectUser ...
func (mrTable *TableTypeUser) SelectUser(queryable mingru.Queryable, id uint64) (*UserTableSelectUserResult, error) {
	result := &UserTableSelectUserResult{}
	err := queryable.QueryRow("SELECT `id`, `name`, `sig` FROM `user` WHERE `id` = ?", id).Scan(&result.ID, &result.Name, &result.Sig)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// SelectUserSig ...
func (mrTable *TableTypeUser) SelectUserSig(queryable mingru.Queryable, id uint64) (*string, error) {
	var result *string
	err := queryable.QueryRow("SELECT `sig` FROM `user` WHERE `id` = ?", id).Scan(&result)
	if err != nil {
		return result, err
	}
	return result, nil
}

// UpdateAllSigToEmpty ...
func (mrTable *TableTypeUser) UpdateAllSigToEmpty(queryable mingru.Queryable) (int, error) {
	result, err := queryable.Exec("UPDATE `user` SET `sig` = ''")
	return mingru.GetRowsAffectedIntWithError(result, err)
}

// UpdateUser ...
func (mrTable *TableTypeUser) UpdateUser(queryable mingru.Queryable, id uint64, name string, sig *string) error {
	result, err := queryable.Exec("UPDATE `user` SET `name` = ?, `sig` = ? WHERE `id` = ?", name, sig, id)
	return mingru.CheckOneRowAffectedWithError(result, err)
}
```

</p>
</details>

<details><summary>`user.sql` for creating table (click to expand/collapse)</summary>
<p>

```sql
CREATE TABLE `user` (
	`id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
	`name` VARCHAR(100) NOT NULL,
	`sig` TEXT NULL DEFAULT NULL,
	`age` INT NOT NULL,
	PRIMARY KEY (`id`)
)
CHARACTER SET=utf8mb4
COLLATE=utf8mb4_unicode_ci
;
```

</p>
</details>

### Step 4: Use the generated code in your Go project

```go
func main() {
	// Open a DB connection on localhost.
	db, err := sql.Open("mysql", "root:123456@/test")
	if err != nil {
		panic(err)
	}

	// Select all user profiles.
	users, err := da.User.SelectAllUserProfiles(db)
	if err != nil {
		panic(err)
	}

	// Loop through the result.
	for _, user := range users {
		fmt.Printf("ID: %v, Name: %v, Sig: %v\n", user.ID, user.Name, user.Sig)
	}
}
```

### More examples

For a more detailed and runnable example, visit [mingru-go-example](https://github.com/mgenware/mingru-go-example)

## Advanced Topics

### Default Values

MySQL doesn't allow you to use a non-constant value as a default value for a column because `CREATE TABLE` doesn't allow it. mingru supports arbitrary default values for both `CREATE` and `UPDATE` actions by simply passing default values into generated SQL.

### Pagination

#### `limit`

Pagination can be achieved by calling `limit` following a call to `selectRows`:

```ts
selectUsersWithLimit = mm.selectRows(user.id, user.name).limit();
```

Implementations should expose arguments to set the underlying SQL `LIMIT` and `OFFSET` values, here is the Go method signature generated by [mingru](https://github.com/mgenware/mingru) from the action above:

```go
func (mrTable *TableTypeUser) SelectUsersWithLimit(queryable mingru.Queryable, limit int, offset int, max int) ([]*SelectUsersWithLimitResult, int, error)
```

#### `selectPage`

Pagination can also be done via `selectPage` method, `selectPage` usually generates a method built upon the SQL `LIMIT` and `OFFSET` clauses but exposes higher level arguments thus provides more convenience:

```ts
selectPagedUsers = mm.selectPage(user.id, user.name);
```

[mingru](https://github.com/mgenware/mingru) converts the action above to the following Go func:

```go
func (mrTable *TableTypeUser) SelectPagedUsers(queryable mingru.Queryable, page int, pageSize int) ([]*SelectPagedUsersResult, bool, error)
```

Notice the `limit` and `offset` arguments are gone, `page` and `pageSize` are exposed instead. Also the second return value changed from `rowsFetched`(`int`) to `hasNextPage`(`bool`).
